<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><meta property="og:title" content="Sharaf" /><meta name="twitter:card" content="summary_large_image" /><title>Search results - Sharaf</title><link rel="shortcut icon" href="images/favicon.png" type="image/png" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2.1.1/css/pico.cyan.min.css" /><link rel="stylesheet" href="styles/main.css" /></head><body><header class="container"><nav><ul><li><img src="images/favicon.png" /></li><li><a href="https://sake92.github.io/sharaf/">Sharaf Docs</a></li></ul><ul><li><form action="search-results.html" method="GET"><input name="q" type="search" placeholder="Search" /></form></li></ul><ul><li><a href="tutorials/index.html">Tutorials</a></li><li><a href="howtos/index.html">How-Tos</a></li><li><a href="reference/index.html">Reference</a></li><li><a href="philosophy/index.html">Philosophy</a></li></ul></nav></header><main class="container"><div><h1>Search results</h1><div id="search-results-content"><p>Loading...</p></div></div></main><footer class="container flex-centered"><a href="https://github.com/sake92/sharaf">
            <?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
            <svg width="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M12 0C5.37 0 0 5.37 0 12C0 17.31 3.435 21.795 8.205 23.385C8.805 23.49 9.03 23.13 9.03 22.815C9.03 22.53 9.015 21.585 9.015 20.58C6 21.135 5.22 19.845 4.98 19.17C4.845 18.825 4.26 17.76 3.75 17.475C3.33 17.25 2.73 16.695 3.735 16.68C4.68 16.665 5.355 17.55 5.58 17.91C6.66 19.725 8.385 19.215 9.075 18.9C9.18 18.12 9.495 17.595 9.84 17.295C7.17 16.995 4.38 15.96 4.38 11.37C4.38 10.065 4.845 8.985 5.61 8.145C5.49 7.845 5.07 6.615 5.73 4.965C5.73 4.965 6.735 4.65 9.03 6.195C9.99 5.925 11.01 5.79 12.03 5.79C13.05 5.79 14.07 5.925 15.03 6.195C17.325 4.635 18.33 4.965 18.33 4.965C18.99 6.615 18.57 7.845 18.45 8.145C19.215 8.985 19.68 10.05 19.68 11.37C19.68 15.975 16.875 16.995 14.205 17.295C14.64 17.67 15.015 18.39 15.015 19.515C15.015 21.12 15 22.41 15 22.815C15 23.13 15.225 23.505 15.825 23.385C18.2072 22.5808 20.2773 21.0498 21.7438 19.0074C23.2103 16.9651 23.9994 14.5143 24 12C24 5.37 18.63 0 12 0Z" fill="#000000"/>
            </svg>
            </a><a href="https://discord.gg/g9KVY3WkMG">
            <?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
            <svg width="24px" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">
               <circle cx="512" cy="512" r="512" style="fill:#5865f2"/>
               <path d="M689.43 349a422.21 422.21 0 0 0-104.22-32.32 1.58 1.58 0 0 0-1.68.79 294.11 294.11 0 0 0-13 26.66 389.78 389.78 0 0 0-117.05 0 269.75 269.75 0 0 0-13.18-26.66 1.64 1.64 0 0 0-1.68-.79A421 421 0 0 0 334.44 349a1.49 1.49 0 0 0-.69.59c-66.37 99.17-84.55 195.9-75.63 291.41a1.76 1.76 0 0 0 .67 1.2 424.58 424.58 0 0 0 127.85 64.63 1.66 1.66 0 0 0 1.8-.59 303.45 303.45 0 0 0 26.15-42.54 1.62 1.62 0 0 0-.89-2.25 279.6 279.6 0 0 1-39.94-19 1.64 1.64 0 0 1-.16-2.72c2.68-2 5.37-4.1 7.93-6.22a1.58 1.58 0 0 1 1.65-.22c83.79 38.26 174.51 38.26 257.31 0a1.58 1.58 0 0 1 1.68.2c2.56 2.11 5.25 4.23 8 6.24a1.64 1.64 0 0 1-.14 2.72 262.37 262.37 0 0 1-40 19 1.63 1.63 0 0 0-.87 2.28 340.72 340.72 0 0 0 26.13 42.52 1.62 1.62 0 0 0 1.8.61 423.17 423.17 0 0 0 128-64.63 1.64 1.64 0 0 0 .67-1.18c10.68-110.44-17.88-206.38-75.7-291.42a1.3 1.3 0 0 0-.63-.63zM427.09 582.85c-25.23 0-46-23.16-46-51.6s20.38-51.6 46-51.6c25.83 0 46.42 23.36 46 51.6.02 28.44-20.37 51.6-46 51.6zm170.13 0c-25.23 0-46-23.16-46-51.6s20.38-51.6 46-51.6c25.83 0 46.42 23.36 46 51.6.01 28.44-20.17 51.6-46 51.6z" style="fill:#fff"/>
            </svg>
            </a></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js"></script><script src="scripts/main.js"></script><script type="module">
    import Fuse from 'https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.mjs'
    
    const urlParams = new URLSearchParams(window.location.search);
    const qParam = urlParams.get('q');
    
    const fuseIndex = await fetch('search-index.json').then(r => r.json())
    const myIndex = Fuse.parseIndex(fuseIndex);
    const fuse = new Fuse([{"text":"Sharaf - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Sharaf Sharaf is a minimalistic Scala 3 web framework. Jump right into: Tutorials to get you started How-Tos to get answers for some common questions Reference to see detailed information Philosophy to get insights into design decisions Site map: Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS Reference Philosophy Alternatives Routes Matching Query Params Dependency Injection Authentication","title":"Sharaf","url":"index.html"},{"text":"Tutorials - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Quickstart Get started quickly with Sharaf framework. Mill def ivyDeps = super.ivyDeps() ++ Agg(\n  ivy\"ba.sake::sharaf:0.10.0\"\n)\ndef scalacOptions = super.scalacOptions() ++ Seq(\"-Yretain-trees\") Sbt libraryDependencies ++= Seq(\n  \"ba.sake\" %% \"sharaf\" % \"0.10.0\"\n),\nscalacOptions ++= Seq(\"-Yretain-trees\") Scala CLI Create a file my_script.sc with the following content: //> using dep ba.sake::sharaf:0.10.0 and then run it with: scala-cli my_script.sc --scala-option -Yretain-trees Examples scala-cli examples, standalone examples using scala-cli scala-cli HTMX examples, standalone examples featuring HTMX API example featuring JSON and validation full-stack example featuring HTML, static files and forms sharaf-todo-backend, implementation of the todobackend.com spec, featuring CORS handling OAuth2 login with Pac4J library PetClinic implementation, featuring full-stack app with Postgres db, config, integration tests etc. Giter8 template for fullstack app","title":"Tutorials","url":"tutorials/index.html"},{"text":"Hello World - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Hello World Let's make a Hello World example with scala-cli. Create a file hello_sharaf.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path(\"hello\", name) =>\n    Response.withBody(s\"Hello $name\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\") Then run it like this: scala-cli hello_sharaf.sc Go to http://localhost:8181/hello/Bob. You will see a \"Hello Bob\" text response. The most interesting part is the Routes definition. Here we pattern match on (HttpMethod, Path). The Path contains a Seq[String], which are the parts of the URL you can match on.","title":"Hello World","url":"tutorials/hello-world.html"},{"text":"Path Params - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Path Parameters Path parameters can be extracted from the Path(segments: Seq[String]) argument. Create a file path_params.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path(\"string\", x) =>\n    Response.withBody(s\"string = \\${x}\")\n\n  case GET -> Path(\"int\", param[Int](x)) =>\n    Response.withBody(s\"int = \\${x}\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\") Then run it like this: scala-cli path_params.sc Now go to http://localhost:8181/string/abc and you will get the param returned: string = abc. When you go to http://localhost:8181/int/123, Sharaf will try to extract an Int from the path parameter. If it doesn't match, it will fall through, try the next route.","title":"Path Params","url":"tutorials/path-params.html"},{"text":"Query Params - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Query Parameters Raw Raw query parameters can be accessed through Request.current.queryParamsRaw. This is a Map[String, Seq[String]] which you can use to extract query parameters. The raw approach is useful for simple cases and dynamic query parameters. Typed For more type safety you can use the QueryStringRW typeclass. Make a case class MyParams(..) derives QueryStringRW and then use it like this: Request.current.queryParams[MyParams] Create a file query_params.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.querson.QueryStringRW\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path(\"raw\") =>\n    val qp = Request.current.queryParamsRaw\n    Response.withBody(s\"params = \\${qp}\")\n\n  case GET -> Path(\"typed\") =>\n    case class SearchParams(q: String, perPage: Int) derives QueryStringRW\n    val qp = Request.current.queryParams[SearchParams]\n    Response.withBody(s\"params = \\${qp}\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\") Then run it like this: scala-cli query_params.sc Now go to http://localhost:8181/raw?q=what&perPage=10 and you will get the raw query params map: params = Map(perPage -> List(10), q -> List(what)) and if you go to http://localhost:8181/typed?q=what&perPage=10 you will get a type-safe, parsed query params object: params = SearchParams(what,10)","title":"Query Params","url":"tutorials/query-params.html"},{"text":"Static Files - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Serving Static Files The static files are automatically served from the resources/public folder (on the classpath): in Mill those are under my_project/resources/public in sbt those are under src/main/resources/public in scala-cli you need to manually tell it where to look for with --resource-dir resources Let's serve an example.js file with Sharaf. First create a file resources/public/example.js. Put this text into it: console.log('Hello Sharaf!');. Now create a file static_files.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(\"Try /example.js\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\") and run it like this: scala-cli static_files.sc  --resource-dir resources Go to http://localhost:8181/example.js. You will see the example.js contents served.","title":"Static Files","url":"tutorials/static-files.html"},{"text":"HTML - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Serving HTML Scalatags You can return a scalatags doctype directly in the Response.withBody(). Let's make a simple HTML page that greets the user. Create a file html.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport scalatags.Text.all.*\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(IndexView)\n  case GET -> Path(\"hello\", name) =>\n    Response.withBody(HelloView(name))\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n\ndef IndexView = doctype(\"html\")(\n  html(\n    p(\"Welcome!\"),\n    a(href := \"/hello/Bob\")(\"Go to /hello/Bob\")\n  )\n)\n\ndef HelloView(name: String) = doctype(\"html\")(\n  html(\n    p(\"Welcome!\"),\n    div(\"Hello \", b(name), \"!\")\n  )\n) and run it like this: scala-cli html.sc Go to http://localhost:8181 to see how it works. Hepek Components Sharaf supports the hepek-components too. Hepek wraps scalatags with helpful utilities like Bootstrap 5 templates, form helpers etc. so you can focus on the important stuff. It is plain scala code as a \"template engine\", so there is no separate language you need to learn. Let's make a simple HTML page that greets the user. Create a file html.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport scalatags.Text.all.*\nimport ba.sake.hepek.html.HtmlPage\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.{*, given}\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(IndexView)\n  case GET -> Path(\"hello\", name) =>\n    Response.withBody(HelloView(name))\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n\n\nobject IndexView extends HtmlPage:\n  override def pageContent = div(\n    p(\"Welcome!\"),\n    a(href := \"/hello/Bob\")(\"Hello world\")\n  )\n\nclass HelloView(name: String) extends HtmlPage:\n  override def pageContent =\n    div(\"Hello \", b(name), \"!\") and run it like this: scala-cli html.sc Go to http://localhost:8181 to see how it works.","title":"HTML","url":"tutorials/html.html"},{"text":"Handling Forms - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Handling Form data Form data can be extracted with Request.current.bodyForm[MyData]. The MyData needs to have a FormDataRW given instance. Create a file form_handling.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport scalatags.Text.all.*\nimport ba.sake.formson.FormDataRW\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(ContactUsView)\n  case POST -> Path(\"handle-form\") =>\n    val formData = Request.current.bodyForm[ContactUsForm]\n    Response.withBody(s\"Got form data: \\${formData}\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(\"Server started at http://localhost:8181\")\n\n\ndef ContactUsView = doctype(\"html\")(\n  html(\n    body(\n      form(action := \"/handle-form\", method := \"POST\")(\n        div(\n          label(\"Full Name: \", input(name := \"fullName\", autofocus))\n        ),\n        div(\n          label(\"Email: \", input(name := \"email\", tpe := \"email\"))\n        ),\n        input(tpe := \"Submit\")\n      )\n    )\n  )\n)\n\ncase class ContactUsForm(fullName: String, email: String) derives FormDataRW Then run it like this: scala-cli form_handling.sc Now go to http://localhost:8181 and fill in the page with some data. When you click the \"Submit\" button you will see a response like this: Got form data: ContactUsForm(Bob,bob@example.com)","title":"Handling Forms","url":"tutorials/handling-forms.html"},{"text":"JSON API - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Model definition Let's make a simple JSON API in scala-cli. Create a file json_api.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.tupson.JsonRW\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\ncase class Car(brand: String, model: String, quantity: Int) derives JsonRW\n\nobject CarsDb {\n  var db: Seq[Car] = Seq()\n  def findAll(): Seq[Car] = db\n  def findByBrand(brand: String): Seq[Car] = db.filter(_.brand == brand)\n  def add(car: Car): Unit = db = db.appended(car)\n} Here we defined a Car model, which derives JsonRW, so we can use the JSON support from Sharaf. We also use a var db: Seq[Car] to store our data. (don't do this for real projects) Routes definition Next step is to define a few routes for getting and adding cars: val routes = Routes:  \n  case GET -> Path(\"cars\") =>\n    Response.withBody(CarsDb.findAll())\n\n  case GET -> Path(\"cars\", brand) =>\n    val res = CarsDb.findByBrand(brand)\n    Response.withBody(res)\n\n  case POST -> Path(\"cars\") =>\n    val reqBody = Request.current.bodyJson[Car]\n    CarsDb.add(reqBody)\n    Response.withBody(reqBody) The first route returns all data in the database. The second route does some filtering on the database. The third route binds the JSON body from the HTTP request. Then we add it to the database. Running the server Finally, start up the server: UndertowSharafServer(\"localhost\", 8181, routes)\n  .withExceptionMapper(ExceptionMapper.json)\n  .start()\n\nprintln(\"Server started at http://localhost:8181\") and run it like this: scala-cli json_api.sc Then try the following requests: # get all cars\ncurl http://localhost:8181/cars\n\n# add a car\ncurl --request POST \\\n  --url http://localhost:8181/cars \\\n  --data '{\n    \"brand\": \"Mercedes\",\n    \"model\": \"ML350\",\n    \"quantity\": 1\n  }'\n\n# get cars by brand\ncurl http://localhost:8181/cars/Mercedes","title":"JSON API","url":"tutorials/json-api.html"},{"text":"Validation - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Validating data For validating data you need to use the Validator typeclass. A small example: import ba.sake.validson.Validator\n\ncase class ValidatedData(num: Int, str: String, seq: Seq[String])\n\nobject ValidatedData:\n  given Validator[ValidatedData] = Validator\n    .derived[ValidatedData]\n    .positive(_.num)\n    .notBlank(_.str)\n    .minItems(_.seq, 1) The ValidatedData can be any case class: json data, form data, query params.. Create a file validation.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.querson.QueryStringRW\nimport ba.sake.tupson.JsonRW\nimport ba.sake.validson.Validator\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path(\"cars\") =>\n    val qp = Request.current.queryParamsValidated[CarQuery]\n    Response.withBody(CarApiResult(s\"Query OK: \\${qp}\"))\n\n  case POST -> Path(\"cars\") =>\n    val json = Request.current.bodyJsonValidated[Car]\n    Response.withBody(CarApiResult(s\"JSON body OK: \\${json}\"))\n\nUndertowSharafServer(\"localhost\", 8181, routes)\n  .withExceptionMapper(ExceptionMapper.json)\n  .start()\n\nprintln(s\"Server started at http://localhost:8181\")\n\n\ncase class Car(brand: String, model: String, quantity: Int) derives JsonRW\nobject Car:\n  given Validator[Car] = Validator\n    .derived[Car]\n    .notBlank(_.brand)\n    .notBlank(_.model)\n    .nonNegative(_.quantity)\n\ncase class CarQuery(brand: String) derives QueryStringRW\nobject CarQuery:\n  given Validator[CarQuery] = Validator\n    .derived[CarQuery]\n    .notBlank(_.brand)\n\ncase class CarApiResult(message: String) derives JsonRW Then run it like this: scala-cli validation.sc Notice above that we used queryParamsValidated and not plain queryParams (does not validate query params). Also, for JSON body parsing+validation we use bodyJsonValidated and not plain bodyJson (does not validate JSON body). When you do a GET http://localhost:8181/cars?brand= you will get a nice JSON error message with HTTP Status of 400 Bad Request: {\n  \"instance\": null,\n  \"invalidArguments\": [\n    {\n      \"reason\": \"must not be blank\",\n      \"path\": \"\\$.brand\",\n      \"value\": \"\"\n    }\n  ],\n  \"detail\": \"\",\n  \"type\": null,\n  \"title\": \"Validation errors\",\n  \"status\": 400\n} The error message format follows the RFC 7807 problem detail. When you do a POST http://localhost:8181/cars with a malformed body: {\n  \"brand\": \" \",\n  \"model\": \"ML350\",\n  \"quantity\": -5\n} you will get these errors: {\n  \"instance\": null,\n  \"invalidArguments\": [\n    {\n      \"reason\": \"must not be blank\",\n      \"path\": \"\\$.brand\",\n      \"value\": \" \"\n    },\n    {\n      \"reason\": \"must not be negative\",\n      \"path\": \"\\$.quantity\",\n      \"value\": \"-5\"\n    }\n  ],\n  \"detail\": \"\",\n  \"type\": null,\n  \"title\": \"Validation errors\",\n  \"status\": 400\n}","title":"Validation","url":"tutorials/validation.html"},{"text":"SQL DB - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext DB setup Create a new Postgres database with Docker: docker run --name sharaf-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres Then connect to it via psql (or your favorite SQL tool): docker exec -it sharaf-postgres psql -U postgres postgres and create a table: CREATE TABLE customers(\n  id SERIAL PRIMARY KEY,\n  name VARCHAR\n); Squery setup Sharaf recommends the Squery library for accessing databases with a JDBC driver. Create a file sql_db.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep org.postgresql:postgresql:42.7.5\n//> using dep com.zaxxer:HikariCP:6.3.0\n//> using dep ba.sake::sharaf-undertow:0.10.0\n//> using dep ba.sake::squery:0.7.0\n\nimport ba.sake.tupson.JsonRW\nimport ba.sake.squery.{*, given}\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval ds = com.zaxxer.hikari.HikariDataSource()\nds.setJdbcUrl(\"jdbc:postgresql://localhost:5432/postgres\")\nds.setUsername(\"postgres\")\nds.setPassword(\"mysecretpassword\")\n\nval ctx = new SqueryContext(ds) Here we set up the SqueryContext which we can use for accessing the database. Querying Now we can do some querying on the db: case class Customer(name: String) derives JsonRW\n\nval routes = Routes:\n  case GET -> Path(\"customers\") =>\n    val customerNames = ctx.run {\n      sql\"SELECT name FROM customers\".readValues[String]()\n    }\n    Response.withBody(customerNames)\n\n  case POST -> Path(\"customers\") =>\n    val customer = Request.current.bodyJson[Customer]\n    ctx.run {\n      sql\"\"\"\n      INSERT INTO customers(name) \n      VALUES (\\${customer.name})\n      \"\"\".insert()\n    }\n    Response.withBody(customer) Running the server Finally, we need to start up the server: UndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\") and run it like this: scala-cli sql_db.sc Then you can try the following requests: # get all customers\ncurl http://localhost:8181/customers\n\n# add a customer\ncurl --request POST \\\n  --url http://localhost:8181/customers \\\n  --data '{\n    \"name\": \"Bob\"\n  }'","title":"SQL DB","url":"tutorials/sql-db.html"},{"text":"Tests - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Tests Tests are essential to any serious software component. Writing integration tests with Munit and Requests is straightforward. Here we are testing the API from the JSON API tutorial. Create a file json_api.test.scala and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::tupson:0.13.0\n//> using dep com.lihaoyi::requests:0.9.0\n//> using test.dep org.scalameta::munit::1.1.1\n\nimport ba.sake.tupson.*\n\ncase class Car(brand: String, model: String, quantity: Int) derives JsonRW\n\nclass JsonApiSuite extends munit.FunSuite {\n\n  val baseUrl = \"http://localhost:8181\"\n\n  test(\"create and get cars\") {\n    locally {\n      val res = requests.get(s\"$baseUrl/cars\")\n      val resBody = res.text.parseJson[Seq[Car]]\n      assertEquals(res.statusCode, 200)\n      assertEquals(res.headers(\"content-type\"), Seq(\"application/json; charset=utf-8\"))\n      assertEquals(res.text.parseJson[Seq[Car]], Seq.empty)\n    }\n\n    locally {\n      val body = Car(\"Mercedes\", \"ML350\", 1)\n      val res = requests.post(s\"$baseUrl/cars\", data = body.toJson)\n      assertEquals(res.statusCode, 200)\n    }\n\n    locally {\n      val res = requests.get(s\"$baseUrl/cars/Mercedes\")\n      val resBody = res.text.parseJson[Seq[Car]]\n      assertEquals(res.statusCode, 200)\n      assertEquals(res.headers(\"content-type\"), Seq(\"application/json; charset=utf-8\"))\n      assertEquals(resBody, Seq(Car(\"Mercedes\", \"ML350\", 1)))\n    }\n  }\n} First run the API server in one shell: scala-cli test json_api.sc and then run the tests in another shell: scala-cli test json_api.test.scala","title":"Tests","url":"tutorials/tests.html"},{"text":"HTMX - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Using HTMX HTMX is an incredibly simple, HTML-first library. Instead of going through HTML->JS->JSON-API loop/mess, you can go directly HTML->HTML-API. Basically you just return HTML snippets that get included where you want in your page. Sharaf is using the hepek-components as its template engine, which has support for HTMX attributes. You can lots of examples in examples/scala-cli/htmx folder. Let's make a simple page that triggers a POST request to fetch a HTML snippet. Create a file htmx_load_snippet.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport scalatags.Text.all.*\nimport ba.sake.hepek.htmx.*\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(IndexView)\n  case POST -> Path(\"html-snippet\") =>\n    Response.withBody(\n      div(\n        b(\"WOW, it works! ðŸ˜²\"),\n        div(\"Look ma, no JS! ðŸ˜Ž\")\n      )\n    )\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n\ndef IndexView = doctype(\"html\")(\n  html(\n    head(\n      script(src := \"https://unpkg.com/htmx.org@2.0.4\")\n    ),\n    body(\n      button(hx.post := \"/html-snippet\", hx.swap := \"outerHTML\")(\"Click here!\")\n    )\n  )\n) and run it like this: scala-cli html.sc Go to http://localhost:8181 to see how it works.","title":"HTMX","url":"tutorials/htmx.html"},{"text":"How-Tos - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How-Tos Here are some common questions and answers you might have when using Sharaf.","title":"How-Tos","url":"howtos/index.html"},{"text":"How To Redirect - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to redirect? Use the Response.redirect function: case GET -> Path(\"a-deprecated-route\") =>\n  Response.redirect(\"/this-other-place\") This will redirect the request to \"/this-other-place\", with status 301 MOVED_PERMANENTLY","title":"How To Redirect","url":"howtos/redirect.html"},{"text":"How To Routes in Sharaf - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to match on multiple methods? You can use the | operator in a pattern match: case (GET | POST) -> Path() =>\n  ... You can always check the Scala docs for more help. If you want to handle all possible methods, just don't use any extractors: case method -> Path() =>\n  ... How to match on multiple paths? You can use the | operator in a pattern match: case GET -> (Path(\"hello\") | Path(\"hello-world\")) =>\n  ... You can always check the Scala docs for more help. If you want to handle all paths that start with \"my-prefix/\": case GET -> Path(\"my-prefix\", segments*) =>\n  ... If you want to handle all possible paths: case GET -> Path(segments*) =>\n  ... How to bind path parameter as an enum? Sharaf needs a FromPathParam[T] instance for the param[T] extractor. It can automatically derive an instance for singleton enums: enum Cloud derives FromPathParam:\n  case aws, gcp, azure\n\nval routes = Routes:\n  case GET -> Path(\"pricing\", param[Cloud](cloud)) =>\n    Response.withBody(s\"cloud = \\${cloud}\") How to bind path parameter as a regex? val userIdRegex = \"user_id_(\\\\d+)\".r\n\nval routes = Routes:\n  case GET -> Path(\"pricing\", userIdRegex(userId)) =>\n    Response.withBody(s\"userId = \\${userId}\") Note that the userId is bound as a String. You could further match on it, for example: val routes = Routes:\n  case GET -> Path(\"pricing\", userIdRegex(param[Int](userId))) => would extract userId as an Int. How to bind a custom path parameter? Sharaf needs a FromPathParam[T] instance available: import ba.sake.sharaf.routing.*\n\ngiven FromPathParam[MyType] with {\n  def parse(str: String): Option[MyType] =\n    parseMyType(str) // impl here\n}\n\nval routes = Routes:\n  case GET -> Path(\"pricing\", param[MyType](myType)) =>\n    Response.withBody(s\"myType = \\${myType}\") How to split Routes? When you have lots of routes, you will want to split them into multiple Routes handlers. Combining them is done with Routes.merge. The order of routes is preserved, of course: val routes: Seq[Routes] = Seq(routes1, routes2, ... )\n\nval allRoutes: Routes = Routes.merge(routes) You can also extend SharafController instead of Routes directly. class MyController1 extends SharafController:\n  override def routes: Routes = Routes:\n    case ...\nclass MyController2 extends SharafController:\n  override def routes: Routes = Routes:\n    case ...\n    \nval server = UndertowSharafServer(\n  new MyController1, new MyController2\n)","title":"How To Routes in Sharaf","url":"howtos/routes.html"},{"text":"How To Query Parameters in Sharaf - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to bind query parameter as an enum? Sharaf needs a QueryStringRW[T] instance for query params. It can automatically derive an instance for singleton enums: enum Cloud derives QueryStringRW:\n  case aws, gcp, azure\n\ncase class MyQueryParams(\n  cloud: Cloud\n) derives QueryStringRW How to bind optional query parameter? The first option is to set the parameter to Option[T]: case class MyQP(mandatory: String, opt: Option[Int]) derives QueryStringRW If you make a request with params ?mandatory=abc, opt will have value of None. The second option is to set the parameter to some default value: case class MyQP2(mandatory: String, opt: Int = 42) derives QueryStringRW Here if you make a request with params ?mandatory=abc the opt will have value of 42. Note that you need the -Yretain-trees scalac flag turned on, otherwise it won't work! How to bind sequence query parameter? Set the parameter to Seq[T]: case class MyQP(seq: Seq[Int]) derives QueryStringRW Let's consider a few possible requests with these query params: ? (empty) -> seq will be empty Seq() ?seq=123 -> seq will be Seq(123) ?seq[]=123&seq[]=456 -> seq will be Seq(123, 456) ?seq[1]=123&seq[0]=456 -> seq will be Seq(456, 123) (note it is sorted here) How to bind composite query parameter? You can make a common query params class and use it in multiple top-level query params, or standalone: case class PageQP(page: Int, size: Int) derives QueryStringRW\ncase class MyQP(q: String, p: PageQP) derives QueryStringRW Sharaf is quite lenient when parsing the query parameters, so all these combinations will work: ?q=abc&p.page=0&p.size=10 -> object style ?q=abc&p[page]=0&p[size]=10 -> brackets style ?q=abc&p[page]=0&p.size=10 -> mixed style (dont) How to bind a custom query parameter? When you want to handle a custom scalar value in query params, you need to implement a QueryStringRW[T] instance manually: import ba.sake.querson.*\n\ngiven QueryStringRW[MyType] with {\n  override def write(path: String, value: MyType): QueryStringData =\n    QueryStringRW[String].write(path, value.toString)\n\n  override def parse(path: String, qsData: QueryStringData): MyType =\n    val str = QueryStringRW[String].parse(path, qsData)\n    Try(MyType.fromString(str)).toOption.getOrElse(typeError(path, \"MyType\", str))\n}\n\nprivate def typeError(path: String, tpe: String, value: Any): Nothing =\n  throw ParsingException(ParseError(path, s\"invalid \\$tpe\", Some(value))) Then you can use it: case class MyQueryParams(\n  myType: MyType\n) derives QueryStringRW Note that Sharaf can automatically derive an instance for singleton enums.","title":"How To Query Parameters in Sharaf","url":"howtos/query-params.html"},{"text":"How To Custom Response Body - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to use a custom response body? You need to define a custom ResponseWritable[T] for your type T. Let's say you have a MyXML class, and you want to use it as a response body. You would write something like this: given ResponseWritable[MyXML] with {\n  override def write(value: MyXML, exchange: HttpServerExchange): Unit =\n    exchange.getResponseSender.send(value.asString)\n  override def headers(value: String): Seq[(HttpString, Seq[String])] = Seq(\n    HttpString(HeaderNames.ContentType) -> Seq(\"text/xml\")\n  )\n} Now you can use MyXML as a response body: val myXml = MyXML(...)\nResponse.withBody(myXml)","title":"How To Custom Response Body","url":"howtos/response-body.html"},{"text":"How To Upload a File - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to upload a file? Uploading a file is usually done via multipart/form-data form submission. // 1. somewhere in a view, use enctype=\"multipart/form-data\"\nform(action := \"/form-submit\", method := \"POST\", enctype := \"multipart/form-data\")(\n  ...\n)\n\n// 2. define form data class with a NIO Path file\nimport java.nio.file.Path\nimport ba.sake.formson.*\n\ncase class MyData(file: Path) derives FormDataRW\n\n// 3. handle the file however you want\ncase POST -> Path(\"form-submit\") =>\n  val formData = Request.current.bodyForm[MyData]\n  val fileAsString = Files.readString(formData.file) You can find a working example in the repo.","title":"How To Upload a File","url":"howtos/upload-file.html"},{"text":"How To Customize NotFound Handler - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to customize 404 NotFound handler? Use the withNotFoundHandler on UndertowSharafServer: UndertowSharafServer(routes).withNotFoundHandler { req =>\n  Response.withBody(MyCustomNotFoundPage)\n    .withStatus(StatusCode.NotFound)\n} The withNotFoundHandler accepts a Request => Response[?] parameter. You can use the request if you need to dynamically decide on what to return. Or ignore it and return a static not found response.","title":"How To Customize NotFound Handler","url":"howtos/not-found.html"},{"text":"How To Customize Exception Handler - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to customize the Exception handler? Use the withExceptionMapper on UndertowSharafServer: val customExceptionMapper: ExceptionMapper = {\n  case e: MyException =>\n    val errorPage = MyErrorPage(e.getMessage())\n    Response.withBody(errorPage)\n        .withStatus(StatusCode.InternalServerError)\n}\nval finalExceptionMapper = customExceptionMapper.orElse(ExceptionMapper.default)\nval server = UndertowSharafServer(routes)\n  .withExceptionMapper(finalExceptionMapper) The ExceptionMapper is a partial function from an exception to Response. Here we need to chain our custom exception mapper before the default one.","title":"How To Customize Exception Handler","url":"howtos/exception-handler.html"},{"text":"How To External Config - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to parse external config? The typesafe config library is already included in Sharaf. Also included is the tupson-config which simplifies the process: import java.net.URL\nimport com.typesafe.config.ConfigFactory\nimport ba.sake.tupson.{given, *}\nimport ba.sake.tupson.config.*\n\ncase class MyConf(\n  port: Int,\n  url: URL,\n  string: String,\n  seq: Seq[String]\n) derives JsonRW\n\nval rawConfig = ConfigFactory.parseString(\"\"\"\n  port = 7777\n  url = \"http://example.com\"\n  string = \"str\"\n  seq = [a, \"b\", c]\n\"\"\")\n\nval myConf = rawConfig.parseConfig[MyConf]\n// MyConf(7777,http://example.com,str,List(a, b, c))","title":"How To External Config","url":"howtos/external-config.html"},{"text":"How To Set CORS - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy How-Tos Redirect Routes Query Parameters Custom Response Body Upload a File Custom NotFound Handler Custom Exception Handler External Config CORS PreviousNext How to set up CORS? By default, Sharaf sets no permitted origins. This means you can only use the API/website from the same domain. If you want to configure it to be available for other domains, use the withCorsSettings method and set desired config: import ba.sake.sharaf.handlers.cors.CorsSettings\nimport ba.sake.sharaf.*\n\nval corsSettings = CorsSettings.default.withAllowedOrigins(Set(\"https://example.com\"))\nUndertowSharafServer(routes).withCorsSettings(corsSettings)...","title":"How To Set CORS","url":"howtos/cors.html"},{"text":"Tutorials - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Tutorials Hello World Path Params Query Params Static Files HTML Handling Forms JSON API Validation SQL DB Tests HTMX PreviousNext Quickstart Get started quickly with Sharaf framework. Mill def ivyDeps = super.ivyDeps() ++ Agg(\n  ivy\"ba.sake::sharaf:0.10.0\"\n)\ndef scalacOptions = super.scalacOptions() ++ Seq(\"-Yretain-trees\") Sbt libraryDependencies ++= Seq(\n  \"ba.sake\" %% \"sharaf\" % \"0.10.0\"\n),\nscalacOptions ++= Seq(\"-Yretain-trees\") Scala CLI Create a file my_script.sc with the following content: //> using dep ba.sake::sharaf:0.10.0 and then run it with: scala-cli my_script.sc --scala-option -Yretain-trees Examples scala-cli examples, standalone examples using scala-cli scala-cli HTMX examples, standalone examples featuring HTMX API example featuring JSON and validation full-stack example featuring HTML, static files and forms sharaf-todo-backend, implementation of the todobackend.com spec, featuring CORS handling OAuth2 login with Pac4J library PetClinic implementation, featuring full-stack app with Postgres db, config, integration tests etc. Giter8 template for fullstack app","title":"Tutorials","url":"tutorials/index.html"},{"text":"Philosophy - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Philosophy Alternatives Routes Matching Query Params Dependency Injection Authentication PreviousNext Why Sharaf? Simplicity and ease of use is the main focus of Sharaf. Sharaf is built on top of Undertow. This means you can use awesome libraries built for Undertow, like pac4j for security and others. You can leverage Undertow's lower level API, e.g. for WebSockets. Sharaf bundles a set of standalone libraries: querson for query parameters tupson for JSON formson for forms validson for validation scalatags for HTML sttp for firing HTTP requests typesafe-config for configuration You can use any of above separately in your projects. Why name \"Sharaf\"? Å araf means a \"screw\" in Bosnian, which reminds me of scala spiral logo. It's a germanism I think.","title":"Philosophy","url":"philosophy/index.html"},{"text":"Alternatives - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Philosophy Alternatives Routes Matching Query Params Dependency Injection Authentication PreviousNext What about other frameworks? Async frameworks like Play, Akka HTTP etc Synchronous programming is much, much easier to understand, debug, profile etc.. Benefits (performance/throughput) of async handling are mostly void in Java 21, with introduction of Virtual threads. Yay! Only bummer for now is that Undertow doesn't still support them.. :/ But undertow is very performant in the current shape too, so for most use cases it will be enough. Java 24 is a game changer for Undertow, because it solves the problem of Synchronize Virtual Threads without Pinning. Pure FP libs like http4s, zio-http etc Too much focus on purely functional programming and (mostly unnecessary) math concepts. Easy to get lost in that and overcomplicate your code. Enterprise frameworks like Spring Framework, Quarkus etc Too much annotations, autoconfigurations, dependency injection, proxies and complexity. Standalone JEE servers like Tomcat, Jetty etc I was looking into these, but then sharaf would have to depend on Servlets API, use @Inject and gazzilion of god-knows-what-they-do annotations just to configure OAuth2 for example...","title":"Alternatives","url":"philosophy/alternatives.html"},{"text":"Routes Matching - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Philosophy Alternatives Routes Matching Query Params Dependency Injection Authentication PreviousNext Routes matching design Web frameworks do their routes matching with various mechanisms: annotation + method param: Spring and most other popular Java frameworks, Cask etc special route file DSL: PlayFramework, Ruby on Rails in-language DSL: zio-http, akka-http pattern matching: Sharaf, http4s Why not annotations? Let's see an example: @GetMapping(value = \"/student/{studentId}\")\npublic Student studentData1(@PathVariable Integer studentId) {}\n\n@GetMapping(value = \"/student/{studentId}\")\npublic Student studentData2(@PathVariable Integer studentId) {}\n\n@GetMapping(value = \"/student/umm\")\npublic Student studentData3(@PathVariable Integer studentId) {} Issues: the studentId appears in 2 places, you can make a typo and nothing will work. the \"/student/{studentId}\" route is duplicated, there is no compiler support and it will fail only in runtime.. you have to wonder if studentData1 will be picked up before studentData3..!? Why not special route file? Well, you need a special compiler for this, essentially a new language. People have to learn how it works, there's probably no syntax highlighting, no autocomplete etc. Why not in-language DSL? Similar to special route file approach, people need to learn it. And again, you don't leverage compiler's support like exhaustive pattern matching and extractors. Sharaf's approach Sharaf does its route matching in plain scala code. Scala's pattern matching warns you when you have duplicate routes, or impossible routes. For example, if you write this: case GET -> Path(\"cars\", brand) => ???\ncase GET -> Path(\"cars\", model) => ??? // Unreachable case\n\ncase GET -> Path(\"files\", segments*) => ???\ncase GET -> Path(\"files\", \"abc.txt\") => ??? // Unreachable case you will get nice warnings, thanks compiler! You can extract path variables with pattern matching: case GET -> Path(\"cars\", param[Int](carId)) => ??? Here, the carId is parsed as Int and it mentioned only once, unlike with the annotation approach.","title":"Routes Matching","url":"philosophy/routes-matching.html"},{"text":"Query Params - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Philosophy Alternatives Routes Matching Query Params Dependency Injection Authentication PreviousNext Query params handling design Web frameworks do handle query params with various mechanisms: annotation + method param: Spring and most other popular Java frameworks, Cask etc special route file DSL: PlayFramework, Ruby on Rails in-language DSL: zio-http pattern matching: http4s parsing from request: Sharaf Why not annotations? This approach is mostly fine, as long as you know from where a parameter comes. In Spring you use the @RequestParam annotation when you have simple parameters. But when you want to group them in a class you don't use it.. #wtf Also, that same class can be bound from the form body too... convenient? eh. In Cask there is no annotation, so it is ambiguous in my opinion. Why not special route file? You need a special compiler for this, essentially a new language. People have to learn how it works, there's probably no syntax highlighting, no autocomplete etc. Why not in-language DSL? Similar to special route file approach, people need to learn it. Not a huge deal I guess. Why not pattern matching? If you look at http4s' approach, you can see that if the query param is not found, it falls through. It is customizable, but more work for you. eh. Essentially you'll get a 404.. which is not a good choice IMO. Rarely any framework does this, and you rarely want to handle the same path in 2 places. Sharaf's approach Sharaf parses query params from the Request. Admittedly, you do have to make a new class if you want to parse them in a typesafe way. But you usually do grouping of these parameters when passing them further, so why not do it immediatelly. Composition adds even more benefits, which I rarely saw implemented in any framework.","title":"Query Params","url":"philosophy/query-params-handling.html"},{"text":"Dependency Injection - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Philosophy Alternatives Routes Matching Query Params Dependency Injection Authentication PreviousNext Do you even Dependency Injection? Not in a classical / \"dependency container\" / Spring / JEE style. Not in a purely-functional-monadic style. Yes in a direct style: for singletons: just instantiate a class and pass the object around. for request/session-scoped instances: use scala 3 context functions (implicit functions). If you ever used PlayFramework, Slick 2 and similar, you might have used this pattern: someFunction { implicit ctx =>\n  // some code that needs an implicit Ctx\n} In Scala 3 there is a new concept called \"context function\" which represents the pattern from above with a type: type ContextualAction = Ctx ?=> Unit Now, instead of manually writing implicit ctx we can skip it: someFunction {\n  // some code that needs an implicit Ctx\n} and compiler will fill it in for us. The Ctx parameter is implicitly/contextually available (only) in the function body. You can get it with summon[Ctx] or using ctx: Ctx (which is a bit more readable). Sharaf has the Routes type that is defined as Request ?=> PartialFunction[RequestParams, Response[?]]. This means that you can call Request.current only in a Routes definition body (because it requires a given Request to be present). If you need a request-scoped instance (a-la @RequestScoped @Bean in Spring), you need to define a function that is using Request: def currentUser(using req: Request): User =\n  // extract stuff from request Same as Request.current, you can only use the currentUser function in a context of a request! By using context functions, you avoid banging your head against the wall while trying to figure out how-the-hell can you inject a request-scoped-thing into a singleton/session-scoped thing... Proxy to proxy to proxy, something, something.. ok. You also avoid reading yet-another-lousy-monad-tutorial, losing your brain-battle agains State, RWS, Kleisli, higher-kinded-types, weird macros, compile times and type inference...","title":"Dependency Injection","url":"philosophy/dependency-injection.html"},{"text":"How To Authentication - Sharaf Sharaf Docs Tutorials How-Tos Reference Philosophy Philosophy Alternatives Routes Matching Query Params Dependency Injection Authentication PreviousNext Authentication Some important security principles from OWASP guidelines: use HTTPS use random user ids to prevent enumeration and other attacks use strong passwords, store them hashed, implement password recovery use MFA, CAPTCHA, rate limiting etc to prevent automated attacks etc. Read all of them in the OWASP auth cheat sheet. Pac4j Authentication in Sharaf is done usually by delegating it to pac4j. Pac4j is a battle-tested and widely used library for authentication and authorization. It supports many authentication mechanisms, including: form based authentication (username + password) OAuth2, with many providers (Google, Facebook, GitHub, etc) Pac4j has a concept of Client, which is a type of authentication mechanism. The main split is between IndirectClient and DirectClient. Indirect clients Indirect clients are used for form based authentication, OAuth2, etc. An important thing to mention here is the callback URL: for username + password authentication, the callback URL where the form is submitted to. Then a server-side session is created and user is signed in. for OAuth2 (and similar mechanisms), the callback URL where the user is redirected to after authentication. The server will then exchange the code for an access token and create a server-side session. Direct clients Direct clients are used for API authentication on every request (e.g. Basic Auth, JWT, etc). On every request, the client will extract the credentials from the request and authenticate the user. Deny by Default Principle One important principle in security is the \"deny by default\" principle. You should use whitelisting, allow access only to what is needed. This is because it is easy to forget to deny something, and it is hard to remember everything that should be denied. Concretely in pac4j, you can use PathMatcher(), to exclude certain paths from authentication: val publicRoutesMatcher = PathMatcher()\npublicRoutesMatcher.excludePaths(\"/\", \"/login-form\")\npac4jConfig.addMatcher(\"publicRoutesMatcher\", publicRoutesMatcher)\n..\nSecurityHandler.build(\n  SharafHandler(..),\n  pac4jConfig,\n  \"client1,client2...\",\n  null,\n  \"securityheaders,publicRoutesMatcher\", // use publicRoutesMatcher here!\n  DefaultSecurityLogic()\n) There are also: excludeBranch(\"/somepath\") to exclude all paths starting with \"/somepath\" excludeRegex(\"^/somepath/.*\\$\") to exclude all paths matching the regex (be careful with this one!)","title":"How To Authentication","url":"philosophy/authentication.html"}], {
      keys: [ "title", "text" ]
    }, myIndex);
    
    const searchRes = fuse.search(qParam);
    console.log(JSON.stringify(searchRes));
    const searchResultsContentElem = document.getElementById("search-results-content");
    searchResultsContentElem.innerHTML = searchRes.map(r => {
      const page = r.item;
      return `<div class="search-result-item">
        <h2><a href="${page.url}">${page.title}</a></h2>
        <p>${page.text}</p>
      </div>`;
    }).join("");
    </script></body></html>