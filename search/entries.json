[{"text":"Response Body How to use a custom response body? You need to define a custom ResponseWritable[T] for your type T. Let's say you have a MyXML class, and you want to use it as a response body. You would write something like this: given ResponseWritable[MyXML] with {\n    override def write(value: MyXML, exchange: HttpServerExchange): Unit =\n      exchange.getResponseSender.send(value.asString)\n    override def headers(value: String): Seq[(HttpString, Seq[String])] = Seq(\n      HttpString(HeaderNames.ContentType) -> Seq(\"text/xml\")\n    )\n}\n Now you can use MyXML as a response body: val myXml = MyXML(...)\nResponse.withBody(myXml)","title":"Response Body","url":"https://sake92.github.io/sharaf/howtos/response-body.html"},{"text":"Exception Handler How to customize the Exception handler? Use the withExceptionMapper on UndertowSharafServer: val customExceptionMapper: ExceptionMapper = {\n  case e: MyException =>\n    val errorPage = MyErrorPage(e.getMessage())\n    Response.withBody(errorPage)\n      .withStatus(StatusCode.InternalServerError)\n}\nval finalExceptionMapper = customExceptionMapper.orElse(ExceptionMapper.default)\nval server = UndertowSharafServer(routes).withExceptionMapper(finalExceptionMapper)\n The ExceptionMapper is a partial function from an exception to Response. Here we need to chain our custom exception mapper before the default one.","title":"Exception Handler","url":"https://sake92.github.io/sharaf/howtos/exception-handler.html"},{"text":"Query Parameters How to bind query parameter as an enum? Sharaf needs a QueryStringRW[T] instance for query params. It can automatically derive an instance for singleton enums: enum Cloud derives QueryStringRW:\n  case aws, gcp, azure\n\ncase class MyQueryParams(\n  cloud: Cloud\n) derives QueryStringRW\n How to bind optional query parameter? The first option is to set the parameter to Option[T]: case class MyQP(mandatory: String, opt: Option[Int]) derives QueryStringRW\n If you make a request with params ?mandatory=abc, opt will have value of None. The second option is to set the parameter to some default value: case class MyQP2(mandatory: String, opt: Int = 42) derives QueryStringRW\n Here if you make a request with params ?mandatory=abc the opt will have value of 42. Note that you need the -Yretain-trees scalac flag turned on, otherwise it won't work! How to bind sequence query parameter? Set the parameter to Seq[T]: case class MyQP(seq: Seq[Int]) derives QueryStringRW\n Let's consider a few possible requests with these query params: ? (empty) -> seq will be empty Seq() ?seq=123 -> seq will be Seq(123) ?seq[]=123&seq[]=456 -> seq will be Seq(123, 456) ?seq[1]=123&seq[0]=456 -> seq will be Seq(456, 123) (note it is sorted here) How to bind composite query parameter? You can make a common query params class and use it in multiple top-level query params, or standalone: case class PageQP(page: Int, size: Int) derives QueryStringRW\ncase class MyQP(q: String, p: PageQP) derives QueryStringRW\n Sharaf is quite lenient when parsing the query parameters, so all these combinations will work: ?q=abc&p.page=0&p.size=10 -> object style ?q=abc&p[page]=0&p[size]=10 -> brackets style ?q=abc&p[page]=0&p.size=10 -> mixed style (dont) How to bind a custom query parameter? When you want to handle a custom scalar value in query params, you need to implement a QueryStringRW[T] instance manually: import ba.sake.querson.*\n\ngiven QueryStringRW[MyType] with {\n  override def write(path: String, value: MyType): QueryStringData =\n    QueryStringRW[String].write(path, value.toString)\n\n  override def parse(path: String, qsData: QueryStringData): MyType =\n    val str = QueryStringRW[String].parse(path, qsData)\n    Try(MyType.fromString(str)).toOption.getOrElse(typeError(path, \"MyType\", str))\n}\n\nprivate def typeError(path: String, tpe: String, value: Any): Nothing =\n  throw ParsingException(ParseError(path, s\"invalid \\$tpe\", Some(value)))\n Then you can use it: case class MyQueryParams(\n  myType: MyType\n) derives QueryStringRW\n Note that Sharaf can automatically derive an instance for singleton enums.","title":"Query Parameters","url":"https://sake92.github.io/sharaf/howtos/query-params.html"},{"text":"Redirect Use the Response.redirect function: case GET -> Path(\"a-deprecated-route\") =>\n    Response.redirect(\"/this-other-place\")\n This will redirect the request to \"/this-other-place\", with status 301 MOVED_PERMANENTLY","title":"Redirect","url":"https://sake92.github.io/sharaf/howtos/redirect.html"},{"text":"Upload File Uploading a file is usually done via multipart/form-data form submission. // 1. somewhere in a view, use enctype=\"multipart/form-data\"\nform(action := \"/form-submit\", method := \"POST\", enctype := \"multipart/form-data\")(\n    ...\n)\n\n// 2. define form data class with a NIO Path file\nimport java.nio.file.Path\nimport ba.sake.formson.*\n\ncase class MyData(file: Path) derives FormDataRW\n\n// 3. handle the file however you want\ncase POST -> Path(\"form-submit\") =>\n  val formData = Request.current.bodyForm[MyData]\n  val fileAsString = Files.readString(formData.file)\n You can find a working example in the repo.","title":"Upload File","url":"https://sake92.github.io/sharaf/howtos/upload-file.html"},{"text":"CORS By default, Sharaf sets no permitted origins. This means you can only use the API/website from the same domain. If you want to configure it to be available for other domains, use the withCorsSettings method and set desired config: import ba.sake.sharaf.handlers.cors.CorsSettings\nimport ba.sake.sharaf.*\n\nval corsSettings = CorsSettings.default.withAllowedOrigins(Set(\"https://example.com\"))\nUndertowSharafServer(routes).withCorsSettings(corsSettings)...","title":"CORS","url":"https://sake92.github.io/sharaf/howtos/cors.html"},{"text":"Routes How to match on multiple methods? You can use the | operator in a pattern match: case (GET | POST) -> Path() =>\n...\n You can always check the Scala docs for more help. If you want to handle all possible methods, just don't use any extractors: case method -> Path() =>\n...\n How to match on multiple paths? You can use the | operator in a pattern match: case GET -> (Path(\"hello\") | Path(\"hello-world\")) =>\n    ...\n You can always check the Scala docs for more help. If you want to handle all paths that start with \"my-prefix/\": case GET -> Path(\"my-prefix\", segments*) =>\n    ...\n If you want to handle all possible paths: case GET -> Path(segments*) =>\n    ...\n How to bind path parameter as an enum? Sharaf needs a FromPathParam[T] instance for the param[T] extractor. It can automatically derive an instance for singleton enums: enum Cloud derives FromPathParam:\n  case aws, gcp, azure\n\nval routes = Routes:\n  case GET -> Path(\"pricing\", param[Cloud](cloud)) =>\n    Response.withBody(s\"cloud = ${cloud}\")\n How to bind path parameter as a regex? val userIdRegex = \"user_id_(\\\\d+)\".r\n\nval routes = Routes:\n  case GET -> Path(\"pricing\", userIdRegex(userId)) =>\n    Response.withBody(s\"userId = ${userId}\")\n Note that the userId is bound as a String. You could further match on it, for example: val routes = Routes:\n  case GET -> Path(\"pricing\", userIdRegex(param[Int](userId))) =>\n would extract userId as an Int. How to bind a custom path parameter? Sharaf needs a FromPathParam[T] instance available: import ba.sake.sharaf.routing.*\n\ngiven FromPathParam[MyType] with {\n  def parse(str: String): Option[MyType] =\n    parseMyType(str) // impl here\n}\n\nval routes = Routes:\n  case GET -> Path(\"pricing\", param[MyType](myType)) =>\n    Response.withBody(s\"myType = ${myType}\")\n How to split Routes? When you have lots of routes, you will want to split them into multiple Routes handlers. Combining them is done with Routes.merge. The order of routes is preserved, of course: val routes: Seq[Routes] = Seq(routes1, routes2, ... )\n\nval allRoutes: Routes = Routes.merge(routes)\n You can also extend SharafController instead of Routes directly. class MyController1 extends SharafController:\n  override def routes: Routes = Routes:\n    case ...\nclass MyController2 extends SharafController:\n  override def routes: Routes = Routes:\n    case ...\n    \nval server = UndertowSharafServer(\n  new MyController1, new MyController2\n)","title":"Routes","url":"https://sake92.github.io/sharaf/howtos/routes.html"},{"text":"External Config The typesafe config library is already included in Sharaf. Also included is the tupson-config which simplifies the process: import java.net.URL\nimport com.typesafe.config.ConfigFactory\nimport ba.sake.tupson.{given, *}\nimport ba.sake.tupson.config.*\n\ncase class MyConf(\n    port: Int,\n    url: URL,\n    string: String,\n    seq: Seq[String]\n) derives JsonRW\n\nval rawConfig = ConfigFactory.parseString(\"\"\"\n    port = 7777\n    url = \"http://example.com\"\n    string = \"str\"\n    seq = [a, \"b\", c]\n\"\"\")\n\nval myConf = rawConfig.parseConfig[MyConf]\n// MyConf(7777,http://example.com,str,List(a, b, c))","title":"External Config","url":"https://sake92.github.io/sharaf/howtos/external-config.html"},{"text":"NotFound How to customize 404 NotFound handler? Use the withNotFoundHandler on UndertowSharafServer: UndertowSharafServer(routes).withNotFoundHandler { req =>\n  Response.withBody(MyCustomNotFoundPage)\n    .withStatus(StatusCode.NotFound)\n}\n The withNotFoundHandler accepts a Request => Response[?] parameter. You can use the request if you need to dynamically decide on what to return. Or ignore it and return a static not found response.","title":"NotFound","url":"https://sake92.github.io/sharaf/howtos/not-found.html"},{"text":"Path Params Path parameters can be extracted from the Path(segments: Seq[String]) argument. Create a file path_params.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path(\"string\", x) =>\n    Response.withBody(s\"string = ${x}\")\n\n  case GET -> Path(\"int\", param[Int](x)) =>\n    Response.withBody(s\"int = ${x}\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n Then run it like this: scala-cli path_params.sc \n Now go to http://localhost:8181/string/abc and you will get the param returned: string = abc. When you go to http://localhost:8181/int/123, Sharaf will try to extract an Int from the path parameter. If it doesn't match, it will fall through, try the next route.","title":"Path Params","url":"https://sake92.github.io/sharaf/tutorials/path-params.html"},{"text":"HTML You can return a scalatags doctype directly in the Response.withBody(). Let's make a simple HTML page that greets the user. Create a file html.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport scalatags.Text.all.*\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(IndexView)\n  case GET -> Path(\"hello\", name) =>\n    Response.withBody(HelloView(name))\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n\ndef IndexView = doctype(\"html\")(\n  html(\n    p(\"Welcome!\"),\n    a(href := \"/hello/Bob\")(\"Go to /hello/Bob\")\n  )\n)\n\ndef HelloView(name: String) = doctype(\"html\")(\n  html(\n    p(\"Welcome!\"),\n    div(\"Hello \", b(name), \"!\")\n  )\n)\n and run it like this: scala-cli html.sc \n Go to http://localhost:8181 to see how it works. Hepek Components Sharaf supports the hepek-components too. Hepek wraps scalatags with helpful utilities like Bootstrap 5 templates, form helpers etc. so you can focus on the important stuff. It is plain scala code as a \"template engine\", so there is no separate language you need to learn. Let's make a simple HTML page that greets the user. Create a file html.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport scalatags.Text.all.*\nimport ba.sake.hepek.html.HtmlPage\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.{*, given}\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(IndexView)\n  case GET -> Path(\"hello\", name) =>\n    Response.withBody(HelloView(name))\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n\n\nobject IndexView extends HtmlPage:\n  override def pageContent = div(\n    p(\"Welcome!\"),\n    a(href := \"/hello/Bob\")(\"Hello world\")\n  )\n\nclass HelloView(name: String) extends HtmlPage:\n  override def pageContent =\n    div(\"Hello \", b(name), \"!\")\n\n and run it like this: scala-cli html.sc \n Go to http://localhost:8181 to see how it works.","title":"HTML","url":"https://sake92.github.io/sharaf/tutorials/html.html"},{"text":"Static Files The static files are automatically served from the resources/public folder (on the classpath): in Mill those are under my_project/resources/public in sbt those are under src/main/resources/public in scala-cli you need to manually tell it where to look for with --resource-dir resources Let's serve an example.js file with Sharaf. First create a file resources/public/example.js. Put this text into it: console.log('Hello Sharaf!');. Now create a file static_files.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(\"Try /example.js\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n and run it like this: scala-cli static_files.sc  --resource-dir resources\n Go to http://localhost:8181/example.js. You will see the example.js contents served.","title":"Static Files","url":"https://sake92.github.io/sharaf/tutorials/static-files.html"},{"text":"JSON Model definition Let's make a simple JSON API in scala-cli. Create a file json_api.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.tupson.JsonRW\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\ncase class Car(brand: String, model: String, quantity: Int) derives JsonRW\n\nobject CarsDb {\n  var db: Seq[Car] = Seq()\n  def findAll(): Seq[Car] = db\n  def findByBrand(brand: String): Seq[Car] = db.filter(_.brand == brand)\n  def add(car: Car): Unit = db = db.appended(car)\n}\n Here we defined a Car model, which derives JsonRW, so we can use the JSON support from Sharaf. We also use a var db: Seq[Car] to store our data. (don't do this for real projects) Routes definition Next step is to define a few routes for getting and adding cars: val routes = Routes:  \n  case GET -> Path(\"cars\") =>\n    Response.withBody(CarsDb.findAll())\n\n  case GET -> Path(\"cars\", brand) =>\n    val res = CarsDb.findByBrand(brand)\n    Response.withBody(res)\n\n  case POST -> Path(\"cars\") =>\n    val reqBody = Request.current.bodyJson[Car]\n    CarsDb.add(reqBody)\n    Response.withBody(reqBody)\n The first route returns all data in the database. The second route does some filtering on the database. The third route binds the JSON body from the HTTP request. Then we add it to the database. Running the server Finally, start up the server: UndertowSharafServer(\"localhost\", 8181, routes)\n  .withExceptionMapper(ExceptionMapper.json)\n  .start()\n\nprintln(\"Server started at http://localhost:8181\")\n and run it like this: scala-cli json_api.sc \n Then try the following requests: # get all cars\ncurl http://localhost:8181/cars\n\n# add a car\ncurl --request POST \\\n    --url http://localhost:8181/cars \\\n    --data '{\n    \"brand\": \"Mercedes\",\n    \"model\": \"ML350\",\n    \"quantity\": 1\n    }'\n\n# get cars by brand\ncurl http://localhost:8181/cars/Mercedes","title":"JSON","url":"https://sake92.github.io/sharaf/tutorials/json.html"},{"text":"Query Params Raw Raw query parameters can be accessed through Request.current.queryParamsRaw. This is a Map[String, Seq[String]] which you can use to extract query parameters. The raw approach is useful for simple cases and dynamic query parameters. Typed For more type safety you can use the QueryStringRW typeclass. Make a case class MyParams(..) derives QueryStringRW and then use it like this: Request.current.queryParams[MyParams] Create a file query_params.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.querson.QueryStringRW\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path(\"raw\") =>\n    val qp = Request.current.queryParamsRaw\n    Response.withBody(s\"params = ${qp}\")\n\n  case GET -> Path(\"typed\") =>\n    case class SearchParams(q: String, perPage: Int) derives QueryStringRW\n    val qp = Request.current.queryParams[SearchParams]\n    Response.withBody(s\"params = ${qp}\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n Then run it like this: scala-cli query_params.sc \n Now go to http://localhost:8181/raw?q=what&perPage=10 and you will get the raw query params map: params = Map(perPage -> List(10), q -> List(what))\n and if you go to http://localhost:8181/typed?q=what&perPage=10 you will get a type-safe, parsed query params object: params = SearchParams(what,10)","title":"Query Params","url":"https://sake92.github.io/sharaf/tutorials/query-params.html"},{"text":"Hello World Let's make a Hello World example with scala-cli. Create a file hello.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path(\"hello\", name) =>\n    Response.withBody(s\"Hello $name\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n Then run it like this: scala-cli hello.sc \n Go to http://localhost:8181/hello/Bob. You will see a \"Hello Bob\" text response. The most interesting part is the Routes definition. Here we pattern match on (HttpMethod, Path). The Path contains a Seq[String], which are the parts of the URL you can match on.","title":"Hello World","url":"https://sake92.github.io/sharaf/tutorials/hello-world.html"},{"text":"SQL DB setup Create a new Postgres database with Docker: docker run --name sharaf-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres\n Then connect to it via psql (or your favorite SQL tool): docker exec -it sharaf-postgres psql -U postgres postgres\n and create a table: CREATE TABLE customers(\n    id SERIAL PRIMARY KEY,\n    name VARCHAR\n);\n Squery setup Sharaf recommends the Squery library for accessing databases with a JDBC driver. Create a file sql_db.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep org.postgresql:postgresql:42.7.5\n//> using dep com.zaxxer:HikariCP:6.3.0\n//> using dep ba.sake::sharaf-undertow:0.10.0\n//> using dep ba.sake::squery:0.7.0\n\nimport ba.sake.tupson.JsonRW\nimport ba.sake.squery.{*, given}\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval ds = com.zaxxer.hikari.HikariDataSource()\nds.setJdbcUrl(\"jdbc:postgresql://localhost:5432/postgres\")\nds.setUsername(\"postgres\")\nds.setPassword(\"mysecretpassword\")\n\nval ctx = new SqueryContext(ds)\n Here we set up the SqueryContext which we can use for accessing the database. Querying Now we can do some querying on the db: case class Customer(name: String) derives JsonRW\n\nval routes = Routes:\n  case GET -> Path(\"customers\") =>\n    val customerNames = ctx.run {\n      sql\"SELECT name FROM customers\".readValues[String]()\n    }\n    Response.withBody(customerNames)\n\n  case POST -> Path(\"customers\") =>\n    val customer = Request.current.bodyJson[Customer]\n    ctx.run {\n      sql\"\"\"\n      INSERT INTO customers(name) \n      VALUES (${customer.name})\n      \"\"\".insert()\n    }\n    Response.withBody(customer)\n\n Running the server Finally, we need to start up the server: UndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n and run it like this: scala-cli sql_db.sc \n Then you can try the following requests: # get all customers\ncurl http://localhost:8181/customers\n\n# add a customer\ncurl --request POST \\\n    --url http://localhost:8181/customers \\\n    --data '{\n    \"name\": \"Bob\"\n    }'","title":"SQL","url":"https://sake92.github.io/sharaf/tutorials/sql.html"},{"text":"Tests Tests are essential to any serious software component. Writing integration tests with Munit and Requests is straightforward. Here we are testing the API from the JSON API tutorial. Create a file json_api.test.scala and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::tupson:0.13.0\n//> using dep com.lihaoyi::requests:0.9.0\n//> using test.dep org.scalameta::munit::1.1.1\n\nimport ba.sake.tupson.*\n\ncase class Car(brand: String, model: String, quantity: Int) derives JsonRW\n\nclass JsonApiSuite extends munit.FunSuite {\n\n  val baseUrl = \"http://localhost:8181\"\n\n  test(\"create and get cars\") {\n    locally {\n      val res = requests.get(s\"$baseUrl/cars\")\n      val resBody = res.text.parseJson[Seq[Car]]\n      assertEquals(res.statusCode, 200)\n      assertEquals(res.headers(\"content-type\"), Seq(\"application/json; charset=utf-8\"))\n      assertEquals(res.text.parseJson[Seq[Car]], Seq.empty)\n    }\n\n    locally {\n      val body = Car(\"Mercedes\", \"ML350\", 1)\n      val res = requests.post(s\"$baseUrl/cars\", data = body.toJson)\n      assertEquals(res.statusCode, 200)\n    }\n\n    locally {\n      val res = requests.get(s\"$baseUrl/cars/Mercedes\")\n      val resBody = res.text.parseJson[Seq[Car]]\n      assertEquals(res.statusCode, 200)\n      assertEquals(res.headers(\"content-type\"), Seq(\"application/json; charset=utf-8\"))\n      assertEquals(resBody, Seq(Car(\"Mercedes\", \"ML350\", 1)))\n    }\n  }\n}\n First run the API server in one shell: scala-cli test json_api.sc\n and then run the tests in another shell: scala-cli test json_api.test.scala","title":"Tests","url":"https://sake92.github.io/sharaf/tutorials/tests.html"},{"text":"HTMX HTMX is an incredibly simple, HTML-first library. Instead of going through HTML->JS->JSON-API loop/mess, you can go directly HTML->HTML-API. Basically you just return HTML snippets that get included where you want in your page. Sharaf is using the hepek-components as its template engine, which has support for HTMX attributes. You can lots of examples in examples/htmx folder. Let's make a simple page that triggers a POST request to fetch a HTML snippet. Create a file htmx_load_snippet.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport scalatags.Text.all.*\nimport ba.sake.hepek.htmx.*\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(IndexView)\n  case POST -> Path(\"html-snippet\") =>\n    Response.withBody(\n      div(\n        b(\"WOW, it works! 😲\"),\n        div(\"Look ma, no JS! 😎\")\n      )\n    )\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(s\"Server started at http://localhost:8181\")\n\ndef IndexView = doctype(\"html\")(\n  html(\n    head(\n      script(src := \"https://unpkg.com/htmx.org@2.0.4\")\n    ),\n    body(\n      button(hx.post := \"/html-snippet\", hx.swap := \"outerHTML\")(\"Click here!\")\n    )\n  )\n)\n and run it like this: scala-cli html.sc \n Go to http://localhost:8181 to see how it works.","title":"HTMX","url":"https://sake92.github.io/sharaf/tutorials/htmx.html"},{"text":"Quickstart Get started quickly with Sharaf framework. Mill def ivyDeps = super.ivyDeps() ++ Agg(\n    ivy\"ba.sake::sharaf-undertow:0.11.1\"\n)\ndef scalacOptions = super.scalacOptions() ++ Seq(\"-Yretain-trees\")\n Sbt libraryDependencies ++= Seq(\n    \"ba.sake\" %% \"sharaf-undertow\" % \"0.11.1\"\n),\nscalacOptions ++= Seq(\"-Yretain-trees\")\n Scala CLI Create a file my_script.sc with the following content: //> using dep ba.sake::sharaf-undertow:0.11.1\n and then run it with: scala-cli my_script.sc --scala-option -Yretain-trees\n Examples scala-cli examples, standalone examples using scala-cli scala-cli HTMX examples, standalone examples featuring HTMX API example featuring JSON and validation full-stack example featuring HTML, static files and forms sharaf-todo-backend, implementation of the todobackend.com spec, featuring CORS handling OAuth2 login with Pac4J library PetClinic implementation, featuring full-stack app with Postgres db, config, integration tests etc. Giter8 template for fullstack app","title":"Quickstart","url":"https://sake92.github.io/sharaf/tutorials/quickstart.html"},{"text":"Validation For validating data you need to use the Validator typeclass. A small example: import ba.sake.validson.Validator\n\ncase class ValidatedData(num: Int, str: String, seq: Seq[String])\n\nobject ValidatedData:\n    given Validator[ValidatedData] = Validator\n    .derived[ValidatedData]\n    .positive(_.num)\n    .notBlank(_.str)\n    .minItems(_.seq, 1)\n The ValidatedData can be any case class: json data, form data, query params.. Create a file validation.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport ba.sake.querson.QueryStringRW\nimport ba.sake.tupson.JsonRW\nimport ba.sake.validson.Validator\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path(\"cars\") =>\n    val qp = Request.current.queryParamsValidated[CarQuery]\n    Response.withBody(CarApiResult(s\"Query OK: ${qp}\"))\n\n  case POST -> Path(\"cars\") =>\n    val json = Request.current.bodyJsonValidated[Car]\n    Response.withBody(CarApiResult(s\"JSON body OK: ${json}\"))\n\nUndertowSharafServer(\"localhost\", 8181, routes)\n  .withExceptionMapper(ExceptionMapper.json)\n  .start()\n\nprintln(s\"Server started at http://localhost:8181\")\n\n\ncase class Car(brand: String, model: String, quantity: Int) derives JsonRW\nobject Car:\n  given Validator[Car] = Validator\n    .derived[Car]\n    .notBlank(_.brand)\n    .notBlank(_.model)\n    .nonNegative(_.quantity)\n\ncase class CarQuery(brand: String) derives QueryStringRW\nobject CarQuery:\n  given Validator[CarQuery] = Validator\n    .derived[CarQuery]\n    .notBlank(_.brand)\n\ncase class CarApiResult(message: String) derives JsonRW\n Then run it like this: scala-cli validation.sc \n Notice above that we used queryParamsValidated and not plain queryParams (does not validate query params). Also, for JSON body parsing+validation we use bodyJsonValidated and not plain bodyJson (does not validate JSON body). When you do a GET http://localhost:8181/cars?brand= you will get a nice JSON error message with HTTP Status of 400 Bad Request: {\n    \"instance\": null,\n    \"invalidArguments\": [\n    {\n        \"reason\": \"must not be blank\",\n        \"path\": \"$.brand\",\n        \"value\": \"\"\n    }\n    ],\n    \"detail\": \"\",\n    \"type\": null,\n    \"title\": \"Validation errors\",\n    \"status\": 400\n}\n The error message format follows the RFC 7807 problem detail. When you do a POST http://localhost:8181/cars with a malformed body: {\n    \"brand\": \" \",\n    \"model\": \"ML350\",\n    \"quantity\": -5\n}\n you will get these errors: {\n    \"instance\": null,\n    \"invalidArguments\": [\n    {\n        \"reason\": \"must not be blank\",\n        \"path\": \"$.brand\",\n        \"value\": \" \"\n    },\n    {\n        \"reason\": \"must not be negative\",\n        \"path\": \"$.quantity\",\n        \"value\": \"-5\"\n    }\n    ],\n    \"detail\": \"\",\n    \"type\": null,\n    \"title\": \"Validation errors\",\n    \"status\": 400\n}","title":"Validation","url":"https://sake92.github.io/sharaf/tutorials/validation.html"},{"text":"Forms Form data can be extracted with Request.current.bodyForm[MyData]. The MyData needs to have a FormDataRW given instance. Create a file form_handling.sc and paste this code into it: //> using scala \"3.7.0\"\n//> using dep ba.sake::sharaf-undertow:0.10.0\n\nimport scalatags.Text.all.*\nimport ba.sake.formson.FormDataRW\nimport ba.sake.sharaf.*\nimport ba.sake.sharaf.undertow.UndertowSharafServer\n\nval routes = Routes:\n  case GET -> Path() =>\n    Response.withBody(ContactUsView)\n  case POST -> Path(\"handle-form\") =>\n    val formData = Request.current.bodyForm[ContactUsForm]\n    Response.withBody(s\"Got form data: ${formData}\")\n\nUndertowSharafServer(\"localhost\", 8181, routes).start()\n\nprintln(\"Server started at http://localhost:8181\")\n\n\ndef ContactUsView = doctype(\"html\")(\n  html(\n    body(\n      form(action := \"/handle-form\", method := \"POST\")(\n        div(\n          label(\"Full Name: \", input(name := \"fullName\", autofocus))\n        ),\n        div(\n          label(\"Email: \", input(name := \"email\", tpe := \"email\"))\n        ),\n        input(tpe := \"Submit\")\n      )\n    )\n  )\n)\n\ncase class ContactUsForm(fullName: String, email: String) derives FormDataRW\n\n Then run it like this: scala-cli form_handling.sc \n Now go to http://localhost:8181 and fill in the page with some data. When you click the \"Submit\" button you will see a response like this: Got form data: ContactUsForm(Bob,bob@example.com)","title":"Forms","url":"https://sake92.github.io/sharaf/tutorials/forms.html"},{"text":"Authentication Some important security principles from OWASP guidelines: use HTTPS use random user ids to prevent enumeration and other attacks use strong passwords, store them hashed, implement password recovery use MFA, CAPTCHA, rate limiting etc to prevent automated attacks etc. Read all of them in the OWASP auth cheat sheet. Pac4j Authentication in Sharaf is done usually by delegating it to pac4j. Pac4j is a battle-tested and widely used library for authentication and authorization. It supports many authentication mechanisms, including: form based authentication (username + password) OAuth2, with many providers (Google, Facebook, GitHub, etc) Pac4j has a concept of Client, which is a type of authentication mechanism. The main split is between IndirectClient and DirectClient. Indirect clients Indirect clients are used for form based authentication, OAuth2, etc. An important thing to mention here is the callback URL: for username + password authentication, the callback URL where the form is submitted to. Then a server-side session is created and user is signed in. for OAuth2 (and similar mechanisms), the callback URL where the user is redirected to after authentication. The server will then exchange the code for an access token and create a server-side session. Direct clients Direct clients are used for API authentication on every request (e.g. Basic Auth, JWT, etc). On every request, the client will extract the credentials from the request and authenticate the user. Deny by Default Principle One important principle in security is the \"deny by default\" principle. You should use whitelisting, allow access only to what is needed. This is because it is easy to forget to deny something, and it is hard to remember everything that should be denied. Concretely in pac4j, you can use PathMatcher(), to exclude certain paths from authentication: val publicRoutesMatcher = PathMatcher()\npublicRoutesMatcher.excludePaths(\"/\", \"/login-form\")\npac4jConfig.addMatcher(\"publicRoutesMatcher\", publicRoutesMatcher)\n..\nSecurityHandler.build(\n    SharafHandler(..),\n    pac4jConfig,\n    \"client1,client2...\",\n    null,\n    \"securityheaders,publicRoutesMatcher\", // use publicRoutesMatcher here!\n    DefaultSecurityLogic()\n)\n There are also: excludeBranch(\"/somepath\") to exclude all paths starting with \"/somepath\" excludeRegex(\"^/somepath/.*\\$\") to exclude all paths matching the regex (be careful with this one!)","title":"Authentication","url":"https://sake92.github.io/sharaf/philosophy/authentication.html"},{"text":"Dependency Injection Do you even Dependency Injection?? Not in a classical / \"dependency container\" / Spring / JEE style. Not in a purely-functional-monadic style. Yes in a direct style: for singletons: just instantiate a class and pass the object around. for request/session-scoped instances: use scala 3 context functions (implicit functions). If you ever used PlayFramework, Slick 2 and similar, you might have used this pattern: someFunction { implicit ctx =>\n    // some code that needs an implicit Ctx\n}\n In Scala 3 there is a new concept called \"context function\" which represents the pattern from above with a type: type ContextualAction = Ctx ?=> Unit\n Now, instead of manually writing implicit ctx we can skip it: someFunction {\n    // some code that needs an implicit Ctx\n}\n and compiler will fill it in for us. The Ctx parameter is implicitly/contextually available (only) in the function body. You can get it with summon[Ctx] or using ctx: Ctx (which is a bit more readable). Sharaf has the Routes type that is defined as Request ?=> PartialFunction[RequestParams, Response[?]]. This means that you can call Request.current only in a Routes definition body (because it requires a given Request to be present). If you need a request-scoped instance (a-la @RequestScoped @Bean in Spring), you need to define a function that is using Request: def currentUser(using req: Request): User =\n    // extract stuff from request\n Same as Request.current, you can only use the currentUser function in a context of a request! By using context functions, you avoid banging your head against the wall while trying to figure out how-the-hell can you inject a request-scoped-thing into a singleton/session-scoped thing... Proxy to proxy to proxy, something, something.. ok. You also avoid reading yet-another-lousy-monad-tutorial, losing your brain-battle agains State, RWS, Kleisli, higher-kinded-types, weird macros, compile times and type inference...","title":"Dependency Injection","url":"https://sake92.github.io/sharaf/philosophy/dependency-injection.html"},{"text":"Query Params Handling Query params handling design Web frameworks do handle query params with various mechanisms: annotation + method param: Spring and most other popular Java frameworks, Cask etc special route file DSL: PlayFramework, Ruby on Rails in-language DSL: zio-http pattern matching: http4s parsing from request: Sharaf Why not annotations? This approach is mostly fine, as long as you know from where a parameter comes. In Spring you use the @RequestParam annotation when you have simple parameters. But when you want to group them in a class you don't use it.. #wtf Also, that same class can be bound from the form body too... convenient? eh. In Cask there is no annotation, so it is ambiguous in my opinion. Why not special route file? You need a special compiler for this, essentially a new language. People have to learn how it works, there's probably no syntax highlighting, no autocomplete etc. Why not in-language DSL? Similar to special route file approach, people need to learn it. Not a huge deal I guess. Why not pattern matching? If you look at http4s' approach, you can see that if the query param is not found, it falls through. It is customizable, but more work for you. eh. Essentially you'll get a 404.. which is not a good choice IMO. Rarely any framework does this, and you rarely want to handle the same path in 2 places. Sharaf's approach Sharaf parses query params from the Request. Admittedly, you do have to make a new class if you want to parse them in a typesafe way. But you usually do grouping of these parameters when passing them further, so why not do it immediatelly. Composition adds even more benefits, which I rarely saw implemented in any framework.","title":"Query Params Handling","url":"https://sake92.github.io/sharaf/philosophy/query-params-handling.html"},{"text":"Alternatives What about other frameworks? Async frameworks like Play, Akka HTTP etc Synchronous programming is much, much easier to understand, debug, profile etc.. Benefits (performance/throughput) of async handling are mostly void in Java 21, with introduction of Virtual threads. Yay! Only bummer for now is that Undertow doesn't still support them.. :/ But undertow is very performant in the current shape too, so for most use cases it will be enough. Java 24 is a game changer for Undertow, because it solves the problem of Synchronize Virtual Threads without Pinning. Pure FP libs like http4s, zio-http etc Too much focus on purely functional programming and (mostly unnecessary) math concepts. Easy to get lost in that and overcomplicate your code. Enterprise frameworks like Spring Framework, Quarkus etc Too much annotations, autoconfigurations, dependency injection, proxies and complexity. Standalone JEE servers like Tomcat, Jetty etc I was looking into these, but then sharaf would have to depend on Servlets API, use @Inject and gazzilion of god-knows-what-they-do annotations just to configure OAuth2 for example...","title":"Alternatives","url":"https://sake92.github.io/sharaf/philosophy/alternatives.html"},{"text":"Routes Matching Routes matching design Web frameworks do their routes matching with various mechanisms:\n- annotation + method param: [Spring](https://spring.io/guides/tutorials/rest/) and most other popular Java frameworks, [Cask](https://com-lihaoyi.github.io/cask/) etc\n- special route file DSL: [PlayFramework](https://www.playframework.com/documentation/2.9.x/ScalaRouting#The-routes-file-syntax), Ruby on Rails\n- in-language DSL: zio-http, akka-http\n- pattern matching: Sharaf, http4s\n Why not annotations? Let's see an example: @GetMapping(value = \"/student/{studentId}\")\npublic Student studentData1(@PathVariable Integer studentId) {}\n\n@GetMapping(value = \"/student/{studentId}\")\npublic Student studentData2(@PathVariable Integer studentId) {}\n\n@GetMapping(value = \"/student/umm\")\npublic Student studentData3(@PathVariable Integer studentId) {}\n Issues: the studentId appears in 2 places, you can make a typo and nothing will work. the \"/student/{studentId}\" route is duplicated, there is no compiler support and it will fail only in runtime.. you have to wonder if studentData1 will be picked up before studentData3..!? Why not special route file? Well, you need a special compiler for this, essentially a new language. People have to learn how it works, there's probably no syntax highlighting, no autocomplete etc. Why not in-language DSL? Similar to special route file approach, people need to learn it. And again, you don't leverage compiler's support like exhaustive pattern matching and extractors. Sharaf's approach Sharaf does its route matching in plain scala code. Scala's pattern matching warns you when you have duplicate routes, or impossible routes. For example, if you write this: case GET -> Path(\"cars\", brand) => ???\ncase GET -> Path(\"cars\", model) => ??? // Unreachable case\n\ncase GET -> Path(\"files\", segments*) => ???\ncase GET -> Path(\"files\", \"abc.txt\") => ??? // Unreachable case\n you will get nice warnings, thanks compiler! You can extract path variables with pattern matching: case GET -> Path(\"cars\", param[Int](carId)) => ???\n Here, the carId is parsed as Int and it mentioned only once, unlike with the annotation approach.","title":"Routes Matching","url":"https://sake92.github.io/sharaf/philosophy/routes-matching.html"},{"text":"How Tos Here are some common questions and answers you might have when using Sharaf.","title":"How Tos","url":"https://sake92.github.io/sharaf/howtos/index.html"},{"text":"Reference Sharaf reference\", Take a look at Sharaf scaladoc.","title":"Reference","url":"https://sake92.github.io/sharaf/reference/index.html"},{"text":"Tutorials Quickstart Hello World Path Params Query Params Static Files HTML Forms JSON Validation SQL Tests HTMX","title":"Tutorials","url":"https://sake92.github.io/sharaf/tutorials/index.html"},{"text":"Tutorials Quickstart Hello World Path Params Query Params Static Files HTML Forms JSON Validation SQL Tests HTMX","title":"Tutorials","url":"https://sake92.github.io/sharaf/tutorials/index-2.html"},{"text":"Sharaf Sharaf is a minimalistic Scala 3 web framework. Jump right into: Tutorials to get you started How-Tos to get answers for some common questions Reference to see detailed information Philosophy to get insights into design decisions Site map: TODO","title":"Sharaf","url":"https://sake92.github.io/sharaf/index.html"},{"text":"Sharaf Sharaf is a minimalistic Scala 3 web framework. Jump right into: Tutorials to get you started How-Tos to get answers for some common questions Reference to see detailed information Philosophy to get insights into design decisions Site map: TODO","title":"Sharaf","url":"https://sake92.github.io/sharaf/index-2.html"},{"text":"Sharaf Sharaf is a minimalistic Scala 3 web framework. Jump right into: Tutorials to get you started How-Tos to get answers for some common questions Reference to see detailed information Philosophy to get insights into design decisions Site map: TODO","title":"Sharaf","url":"https://sake92.github.io/sharaf/index-3.html"},{"text":"Philosophy Why Sharaf? Simplicity and ease of use is the main focus of Sharaf. Sharaf is built on top of Undertow. This means you can use awesome libraries built for Undertow, like pac4j for security and others. You can leverage Undertow's lower level API, e.g. for WebSockets. Sharaf bundles a set of standalone libraries: querson for query parameters tupson for JSON formson for forms validson for validation scalatags for HTML sttp for firing HTTP requests typesafe-config for configuration You can use any of above separately in your projects. Why name \"Sharaf\" Šaraf means \"a screw\" in Bosnian, which reminds me of scala spiral logo. It's a germanism I think.","title":"Philosophy","url":"https://sake92.github.io/sharaf/philosophy/index.html"}]